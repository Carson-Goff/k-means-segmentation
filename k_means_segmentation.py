# -*- coding: utf-8 -*-
"""k-means-segmentation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kX7VAbKstxPHXeM3yQEWDE3PTrd5RCdq
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.cluster import KMeans
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
from sklearn.metrics import silhouette_score
from sklearn.impute import SimpleImputer

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
sns.set(style="whitegrid")  # for plot styling
plt.rcParams['figure.figsize'] = (10, 6)

train_data = pd.read_csv('data/Train.csv')
test_data = pd.read_csv('data/Test.csv')
sample_submission = pd.read_csv('data/sample_submission.csv')

print("Shape of the Training dataset:", train_data.shape)
print("Shape of the Testing dataset:", test_data.shape)
print("Shape of the Sample Submission dataset:", sample_submission.shape)
print("First few rows of the Training dataset:")
display(train_data.head())
print("Training Data Info:")
train_data.info()

numeric_cols = train_data.select_dtypes(include=[np.number]).columns.tolist()
categorical_cols = train_data.select_dtypes(exclude=[np.number]).columns.tolist()

print("Numeric columns:", numeric_cols)
print("Categorical columns:", categorical_cols)

train_data_encoded = pd.get_dummies(train_data, columns=categorical_cols, drop_first=True)

train_data.hist(bins=15, color='steelblue', edgecolor='black', linewidth=1.5, xlabelsize=8, ylabelsize=8, grid=False)
plt.tight_layout(rect=(0, 0, 1.2, 1.2))

# Correlation matrix heatmap
corr_matrix = train_data_encoded.corr()
plt.figure(figsize=(12, 10))
sns.heatmap(corr_matrix, annot=True, fmt=".2f", annot_kws={"size": 8})
plt.title("Correlation Matrix")
plt.show()

new_numeric_cols = train_data_encoded.columns.tolist()

num_imputer = SimpleImputer(strategy='mean')
train_data_encoded[new_numeric_cols] = num_imputer.fit_transform(train_data_encoded[new_numeric_cols])

wcss = []  # Within-cluster sum of squares
for i in range(1, 11):  # Test 1 to 10 clusters
    kmeans = KMeans(n_clusters=i, init='k-means++', max_iter=300, n_init=10, random_state=0)
    kmeans.fit(train_data_encoded)
    wcss.append(kmeans.inertia_)

# Plot the results
plt.plot(range(1, 11), wcss)
plt.title('The Elbow Method')
plt.xlabel('Number of clusters')
plt.ylabel('WCSS')  # Within cluster sum of squares
plt.show()

optimal_k = 4
kmeans = KMeans(n_clusters=optimal_k, init='k-means++', max_iter=300, n_init=10, random_state=0)
kmeans.fit(train_data_encoded.select_dtypes(include=[np.number]))

train_data['Cluster'] = kmeans.labels_
train_data_encoded['Cluster'] = kmeans.labels_

print("Counts of data points in each cluster:")
print(train_data_encoded['Cluster'].value_counts())

numeric_columns = train_data_encoded.select_dtypes(include=[np.number]).columns.tolist()
clustered_data = train_data_encoded.groupby('Cluster')[numeric_columns].mean()

print("\nCluster Characteristics:")
print(clustered_data)

feature1 = numeric_columns[0]
feature2 = numeric_columns[1]

# Create scatter plot
plt.figure(figsize=(10, 6))
sns.scatterplot(data=train_data_encoded, x=feature1, y=feature2, hue='Cluster', palette='viridis', style='Cluster', s=100)
plt.title('Cluster Visualization')
plt.xlabel(feature1)
plt.ylabel(feature2)
plt.legend(title='Cluster', bbox_to_anchor=(1.05, 1), loc=2)
plt.show()

# Apply PCA
pca = PCA(n_components=2)
principal_components = pca.fit_transform(train_data_encoded[numeric_columns])

pca_df = pd.DataFrame(data=principal_components, columns=['Principal Component 1', 'Principal Component 2'])
pca_df['Cluster'] = train_data_encoded['Cluster']

plt.figure(figsize=(10, 6))
sns.scatterplot(data=pca_df, x='Principal Component 1', y='Principal Component 2', hue='Cluster', palette='viridis', s=100)
plt.title('PCA Cluster Visualization')
plt.xlabel('Principal Component 1')
plt.ylabel('Principal Component 2')
plt.legend(title='Cluster', bbox_to_anchor=(1.05, 1), loc=2)
plt.show()